#!/bin/bash

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

PS3=$'\e[01;33mChoice: \e[0m' # yellow prompt
# colors
NC='\033[0m' # No Color
RED='\033[0;31m'
GREEN='\033[0;32m'
BROWN='\033[0;33m'
ORANGE='\033[0;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
LIGHT_GRAY='\033[0;37m'
DARK_GRAY='\033[1;30m'
LIGHT_RED='\033[1;31m'
LIGHT_GREEN='\033[1;32m'
YELLOW='\033[1;33m'
LIGHT_BLUE='\033[1;34m'
LIGHT_PURPLE='\033[1;35m'
LIGHT_CYAN='\033[1;36m'
WHITE='\033[1;36m'


# get terminal dimensions
columns=$(tput cols)

# COPYPASTAS

### RICHARD STALLMAN GNU LINUX ###
GNU="I'd just like to interject for a moment.  What you're referring to as Linux, is in fact, GNU/Linux, or as I've recently taken to calling it, GNU plus Linux. Linux is not an operating system unto itself, but rather another free component of a fully functioning GNU system made useful by the GNU corelibs, shell utilities and vital system components comprising a full OS as defined by POSIX.\n\nMany computer users run a modified version of the GNU system every day, without realizing it.  Through a peculiar turn of events, the version of GNU which is widely used today is often called \"Linux\", and many of its users are not aware that it is basically the GNU system, developed by the GNU Project.\n\nThere really is a Linux, and these people are using it, but it is just a part of the system they use.  Linux is the kernel: the program in the system that allocates the machine's resources to the other programs that you run. The kernel is an essential part of an operating system, but useless by itself; it can only function in the context of a complete operating system. Linux is normally used in combination with the GNU operating system: the whole system is basically GNU with Linux added, or GNU/Linux.  All the so-called \"Linux\" distributions are really distributions of GNU/Linux."
GNU=$(fold -sw $columns <<< $GNU)

### NO RICHARD ITS LINUX ###
No_its_linux="No, Richard, it's 'Linux', not 'GNU/Linux'. The most important contributions that the FSF made to Linux were the creation of the GPL and the GCC compiler. Those are fine and inspired products. GCC is a monumental achievement and has earned you, RMS, and the Free Software Foundation countless kudos and much appreciation.\n\nFollowing are some reasons for you to mull over, including some already answered in your FAQ.\n\nOne guy, Linus Torvalds, used GCC to make his operating system (yes, Linux is an OS -- more on this later). He named it 'Linux' with a little help from his friends. Why doesn't he call it GNU/Linux? Because he wrote it, with more help from his friends, not you. You named your stuff, I named my stuff -- including the software I wrote using GCC -- and Linus named his stuff. The proper name is Linux because Linus Torvalds says so. Linus has spoken. Accept his authority. To do otherwise is to become a nag. You don't want to be known as a nag, do you?\n\n(An operating system) != (a distribution). Linux is an operating system. By my definition, an operating system is that software which provides and limits access to hardware resources on a computer. That definition applies whereever you see Linux in use. However, Linux is usually distributed with a collection of utilities and applications to make it easily configurable as a desktop system, a server, a development box, or a graphics workstation, or whatever the user needs. In such a configuration, we have a Linux (based) distribution. Therein lies your strongest argument for the unwieldy title 'GNU/Linux' (when said bundled software is largely from the FSF). Go bug the distribution makers on that one. Take your beef to Red Hat, Mandrake, and Slackware. At least there you have an argument. Linux alone is an operating system that can be used in various applications without any GNU software whatsoever. Embedded applications come to mind as an obvious example\n\nNext, even if we limit the GNU/Linux title to the GNU-based Linux distributions, we run into another obvious problem. XFree86 may well be more important to a particular Linux installation than the sum of all the GNU contributions. More properly, shouldn't the distribution be called XFree86/Linux? Or, at a minimum, XFree86/GNU/Linux? Of course, it would be rather arbitrary to draw the line there when many other fine contributions go unlisted. Yes, I know you've heard this one before. Get used to it. You'll keep hearing it until you can cleanly counter it.\n
You seem to like the lines-of-code metric. There are many lines of GNU code in a typical Linux distribution. You seem to suggest that (more LOC) == (more important). However, I submit to you that raw LOC numbers do not directly correlate with importance. I would suggest that clock cycles spent on code is a better metric. For example, if my system spends 90% of its time executing XFree86 code, XFree86 is probably the single most important collection of code on my system. Even if I loaded ten times as many lines of useless bloatware on my system and I never excuted that bloatware, it certainly isn't more important code than XFree86. Obviously, this metric isn't perfect either, but LOC really, really sucks. Please refrain from using it ever again in supporting any argument.\n\nLast, I'd like to point out that we Linux and GNU users shouldn't be fighting among ourselves over naming other people's software. But what the heck, I'm in a bad mood now. I think I'm feeling sufficiently obnoxious to make the point that GCC is so very famous and, yes, so very useful only because Linux was developed. In a show of proper respect and gratitude, shouldn't you and everyone refer to GCC as 'the Linux compiler'? Or at least, 'Linux GCC'? Seriously, where would your masterpiece be without Linux? Languishing with the HURD?\n\nIf there is a moral buried in this rant, maybe it is this:\n\nBe grateful for your abilities and your incredible success and your considerable fame. Continue to use that success and fame for good, not evil. Also, be especially grateful for Linux' huge contribution to that success. You, RMS, the Free Software Foundation, and GNU software have reached their current high profiles largely on the back of Linux. You have changed the world. Now, go forth and don't be a nag.\n\nThanks for listening."
No_its_linux=$(fold -sw $columns <<< $No_its_linux)

### UNKEMPT BEARDED MAN ###
Old_Man="I use Linux as my operating system,\" I state proudly to the unkempt, bearded man. He swivels around in his desk chair with a devilish gleam in his eyes, ready to mansplain with extreme precision. \"Actually\", he says with a grin, \"Linux is just the kernel. You use GNU+Linux!' I don't miss a beat and reply with a smirk, \"I use Alpine, a distro that doesn't include the GNU Coreutils, or any other GNU code. It's Linux, but it's not GNU+Linux.\"\n\nThe smile quickly drops from the man's face. His body begins convulsing and he foams at the mouth and drops to the floor with a sickly thud. As he writhes around he screams \"I-IT WAS COMPILED WITH GCC! THAT MEANS IT'S STILL GNU!\" Coolly, I reply \"If windows were compiled with GCC, would that make it GNU?\" I interrupt his response with \"-and work is being made on the kernel to make it more compiler-agnostic. Even if you were correct, you won't be for long.\"\n\nWith a sickly wheeze, the last of the man's life is ejected from his body. He lies on the floor, cold and limp. I've womansplained him to death."
Old_Man=$(fold -sw $columns <<< $Old_Man)

### PROPRIETARY BITCH
Proprietary_Bitch="What the fuck did you just fucking say about me, you little proprietry bitch? I'll have you know I graduated top of my class in the FSF, and I've been involved in numerous secret raids on Apple patents, and I have over 300 confirmed bug fixes. I am trained in Free Software Evangelizing and I'm the top code contributer for the entire GNU HURD. You are nothing to me but just another compile time error. I will wipe you the fuck out with precision the likes of which has never been seen before on this Earth, mark my fucking words. You think you can get away with saying that shit to me over the Internet? Think again, fucker. As we speak I am building a GUI using GTK+ and your IP is being traced right now so you better prepare for the storm, maggot. The storm that wipes out the pathetic little thing you call your life. You're fucking dead, kid. I can be anywhere, anytime, and I can decompile you in over seven hundred ways, and that's just with my Model M. Not only am I extensively trained in EMACS, but I have access to the entire arsenal of LISP functions and I will use it to its full extent to wipe your miserable ass off the face of the continent, you little shit. If only you could have known what unholy retribution your little \"clever\" comment was about to bring down upon you, maybe you would have held your fucking tongue. But you couldn't, you didn't, and now you're paying the price, you goddamn idiot. I will shit Freedom all over you and you will drown in it. You're fucking debugged, kiddo."
Proprietary_Bitch=$(fold -sw $columns <<< $Proprietary_Bitch)

### UBUNTU KIDDIE
Ubuntu_kiddie="A lamer Ubuntu-using script kiddie corporate shill professor was teaching a class on Mark Shuttleworth, known corporate spy and Linux ’programmer’.\n\n\"Before the class begins, you must get on your knees and worship Shuttleworth and accept that he was the most highly-evolved programmer the world has ever known, even greater than Richard Stallman!\"\n\nAt this moment, a brave, i3-using, bash scripting Poweruser who had over 1500 vertically-segmented Terminator windows and understood the necessity of systemd and fully supported all design decisions made by the Arch developers stood up and held up his sister’s netbook.\n\n\"What’s this computer doing, pinhead?\"\n\nThe arrogant professor smirked quite graphically and smugly replied \"It’s clearly using apt-get to update Ubuntu with all the latest software.\"\n\n\"Wrong. It’s been 5,000 years since these packages were released. If it was actually installing the latest and best software, as you say… then it should be running Arch by now.\"\n\nThe professor was visibly shaken, and dropped his Ubuntu phone and list of Amazon referral links. He stormed out of the room crying those shill corporate bloatware tears. There is no doubt that at this point our professor, Robbie Williamson, wished he had pulled himself up by his bootstraps and become more than a GNOME Unity user. He wished so much that he had a some privacy to shield himself from embarrassment, but he himself had sent his search history to Canonical’s servers!\n\nThe students applauded and all installed Arch that day and accepted Aaron Griffin as their lord and savior. An eagle named \"linux-ck\" flew into the room and perched atop the American Flag and shed a tear on the chalkboard. The ArchWiki was read several times, and Judd Vinet himself showed up and enacted a rolling release system across the country.\n\nThe professor lost his tenure and was fired the next day. His system experienced kernel panic and he was forced to reinstall Windows for all eternity.\n\nKISS."
Ubuntu_kiddie=$(fold -sw $columns <<< $Ubuntu_kiddie)

### INSTALLING
Installation="The sole reason to install Linux is to free yourself from the idiots that infest inferior platforms. Unfortunately for the Linux user community, distributions like Ubuntu have made it too easy for your mom to get a working Linux box -- so they are all running in horror.\n\nInstalling a working Linux box used to require over 550 man hours, learning a Nordic language, sacrificing a goat, wading through hundreds of pages of (purposely) inscrutable help files, and in some cases programming a new driver in UNIVAC SLEUTH II assembly code using nothing but punch cards while walking miles through the snow barefoot on the wrong side of the tracks and uphill both ways. Today, Linux distros are so idiot-proof that you can put their install CDs into the floppy drive upside-down and the fucker will still work.\n\nOld-school Linux users were desperate to find a new way to feel superior. Some migrated to versions of BSD, others gave into baroque feats of self-torture like multi-booting 4 different operating systems from one USB drive. But it didn't have the same appeal as abusing other operating systems for their lack of 1337n355.\n\nIn this dark hour there was a new hope: Gentoo Linux, a distribution designed for users possessing that delicate combination of insecurity and masochism that results in an obsession with obscurity, optimization, and huge dollops of pain and frustration. Gentoo has sated all of these urges.\n\nEnter the idea of a \"hemorrhaging edge\" distro: Gentoo. It is the exemplar of the term \"hemorrhaging edge\" -- there is no piece of software too advanced, too experimental, or too downright dangerous for the main tree. In fact, if the users don't crash their box at least once a week due to new and untestedsoftware they will swarm onto the forums and accuse Gentoo of \"going all Debian\" on them. After the separate Stable and Unstable branches were created, every user switched immediately to Unstable which became the new de-facto Stable. As a response, the Gentoo developers invented a new Super-Unstable overlay system and made it as hard and annoying to use as possible in order to keep the stupid masses out, thus cementing their own position at the top of the hobbyist heap. This has worked, to a point, but a group of developers has formed in order to create a Gentoo offshoot, Exherbo (\"Cannabis Withdrawal\") where the system tools are in erudite Latin instead of plain English and normal users are instructed on the web page to stay far away for fear of spoiling the 1337."
Installation=$(fold -sw $columns <<< $Installation)

### FAMILY
Family="Here's the thing. You said \"Linux is an OS.\" Is it in the same family? Yes. No one's arguing that. As someone who is a programmer who studies freedom, I am telling you, specifically, in the FSF, no one calls Linux an OS. If you want to be \"specific\" like you said, then you shouldn't either. They're not the same thing. If you're saying \"operating system\" you're referring to the full OS as defined by POSIX, which includes things from corelibs to shell utilities to vital system components. So your reasoning for calling Linux an OS is because random people \"call their free systems Linux?\" Let's get FreeBSD and Haiku in there, then, too. Also, calling someone a human or an ape? It's not one or the other, that's not how taxonomy works. They're both. Linux is Linux and a free component of a fully functioning GNU system. But that's not what you said. You said Linux is an OS, which is not true unless you're okay with calling all members of the kernel family OSes, which means you'd call XNU, BSD, and other kernels OSes, too. Which you said you don't. It's okay to just admit you're wrong, you know?"
Family=$(fold -sw $columns <<< $Family)

### REGEX 
Regex="Regexing with several editors:\n\ned:\n\n\t?\n\n\t?\n\n\t?\n\nacme:\n\n\tOh, I want to execute a regular expression on my text here.\n\n\tHere I go.\n\n\tI take my mouse hand off my keys.\n\n\tI move my mouse hand to my mouse\n\n\tI grip the mouse with my mouse hand\n\n\tI move the mouse to the tab strip on top of the editing buffer\n\n\tI click the tab strip\n\n\tI release the mouse\n\n\tI move my mouse hand to the keys\n\n\tI write the regex\n\n\tI take my mouse hand off the keys\n\n\tI move my mouse hand to my mouse\n\n\tI grip the mouse and press da butans\n\n\tI drag the mouse over the regex to highlight it\n\n\tI release da butans\n\n\tI watch as my regex hopefully does what it needs to do on the first try.\n\n\tI move the mouse to the editing buffer to continue inputting text\n\n\tI release the mouse\n\n\tI move my mouse hand to the keys\n\n\tI FINALLY start typing again.\n\nEmacs:\n\n\tpress both foot pedals\n\n\tpress meta shift control sysrq\n\n\tplay the moonlight sonata on the two extra keyboards while requesting Regex-Mode with the headstick.\n\n\thit the electric cymbals strapped under my arm and while putting the shift-stick I have gripped tightly with my sphincter into turbo mode.\n\n\tsignal my two assistants to turn their keys in unison, NOW!\n\n\tinput the regex\n\n\trelease all keys and watch as emacs gracefully rearranges the text\n\nvim:\n\n\tescape or equivalent\n\n\t:%s/foo/bar/g\n\n\tenter\n\n\tcontinue editing"

### EMACS
Defend_Emacs="Whoa. So, before I 'defend' Emacs, I have to be very careful you know that this is not just a knee-jerk reaction and 'HeY yU iNsUlTeD mAh EmAcS', and that it is not unreasonable to think emacs is outdated. Emacs being outdated is most likely a myth, and that impression will most likely be spread by the fact that many don't use emacs, and never actually get to learn about what it is. It is often compared to text editors, namely Vim, and that is all the more reason it will just look like some old text editor, but it is not that at all. Emacs is not a text editor, emacs contains a text editor. Emacs is more like an example of ancient magic that people once had a hold on and was lost in modern times to some extent. The reason is its a full programming language interpreter with a text editor, at the bare minimum, built on top of it (and to the person who asked why 'nobody builds these things for IDE's', I don't know if that's true, but if there's any truth to it this may be partially why; not every IDE is a programming language, nor does every IDE allow full turing complete modding. Emacs is exceedingly suited for change, even ridiculous change). Better yet, the language it uses is possibly the most dynamic language in the world (lisp), one that allows you to touch and play with the code of the device while its live, and add on to it effortlessly. Hell, a language that allows you to modify the language itself. That is the pinnacle of modding and customization.\n\nAnyways, because of this, its true power is not in its text editor -- many of us forgo the emacs text editing and just integrate vim's text editing into it. It does have a powerful text editor though, I still end up text editing Emacs style more often than Vim style, but anyways -- it is its power as a sort of operating system. You can always build new emacs tools, full programs if you will, and similarly we have continued to build emacs tools over time. You are not using 1970s emacs in 2019, it is still alive and well and extended. Emacs, as it looked when it first came out, was just a starting point, since its not like a normal program which is just a snapshot in time, but a fully organic starting point to grow anything.\n\nIt has some graphical limitations, not in functionality but in pure appearance, which can further give the appearance of being outdated, but none of the practical limitations.\n
Because of emacs' dynamic language nature, there is another secret gem that might be the true source of its power -- integration. Every tool you add to emacs can often be used in conjunction with every other tool in a very polymorphic way, which means adding features is less like \"emacs + n + m\" and more like \"emacs * n * m\"; every feature boosts every other feature. This has resulted in some tools that are true outliers, with true power that may not be emulated elsewhere, like org mode and magit (please look into magit if you haven't). Emacs can accommodate many workflows, and teach you some newer ones.\n\nAnyways, as for actual emacs users, the number is not insignificant either. It doesn't have a majority usage, but I will usually see it with at least a 5% or 15% in different community interviews (example: https://insights.stackoverflow.com/survey/2016 ~5.2%). Looking at this survey, that puts it on the same usage (about) as PyCharm , VsCode, and PhpStorm, differing by about 2%, and about half the users of Atom, and it has several more users (in this survey sample) than a common editor like TextMate. It is still a common editor, just with an image of being old or unused or uncommon at time, if anything because its old.\n\nJust as a reminder for the 400th time, one of the strangest things about emacs is its called a text editor, and maybe because in the beginning, that's all there were, and that's what its image became cemented as. Emacs is an IDE, a mini operating system, and much more, and never have I gotten as much features elsewhere as I have in emacs (although I do not claim they are not there), and never have I had the combined features you get from the unique combination and integration of all these features within it. From what I've seen, some emacs features are less refined than some other IDE counterparts, others are more refined. Emacs often (not always) requires more tinkering, an IDE less so. I have had times where I was able to use a huge mod pack for emacs 'out the box' like I would an IDE, and other times where it needed some adjusting. I will say its a bit like android vs ios; android if you want to tinker and freedom, ios if you want something that just works and don't want the freedom to break something. I will not be so bold as to say emacs is going to be the universal best for everything, just that its not outdated, and that it is going to have a very long shelf life. I do possible hope to one day, however, work on a new emacs with a makeover and an overhauled branding, as the latter I think is more what emacs is outdated on; its brand. I luv emacs. T-thanks for reading"
Defend_Emacs=$(fold -sw $columns <<< $Defend_Emacs)

### STALLMAN QUOTE
Stallman_Quote="To have the choice between proprietary software packages, is being able to choose your master. Freedom means not having a master. And in the area of computing, freedom means not using proprietary software. - Richard Stallman"
Stallman_Quote=$(fold -sw $columns <<< $Stallman_Quote)

### WINDOWS TORVALDS QUOTE
Windows_Quote="\"A computer is like air conditioning – it becomes useless when you open Windows. - Linus Torvalds\""
Windows_Quote=$(fold -sw $columns <<< $Windows_Quote)

### SYSTEMD BAD
Systemd_Bad="How many times do I have to tell you, simpleton, that systemd is the shittiest init ever? USE A PROPER INIT SYSTEM INSTEAD OF SYSTEMD!\n\nFirst of all,\n\nInit is the first process started during system boot. It is a daemon process that continues running until the system is shut down. Init is the direct or indirect ancestor of all other processes, and automatically adopts all orphaned processes. It is started by the kernel using a hard-coded filename; if the kernel is unable to start it, panic will result. Init is typically assigned process identifier 1.\n\nThe init scripts (aka rc runtime configuration scripts) are launched by the init process to guarantee basic functionality on system start and shutdown. This includes (un)mounting of file systems and launching of daemons. A service manager takes this one step further by providing active control over launched processes, or process supervision. An example is to monitor for crashes and restart processes accordingly.\n\nThese components combine to the init system. Some init systems incorporate the service manager in the init process or have init scripts in close relation to them. Below, such init systems are referred to as integrated, although entries in different categories may explicitly depend on each other.\n\nSecond of all, here's all the disadvantages of systemd:\n\nsystemd suffers from scope creep. And the scope creep leads to vulnerabilities, such as: systemd-resolved DNS cache poisoning [seclists.org] To run systemd properly in container a FUSE LXCFS had to be created, and surely its own share of vulnerabilities: LXCFS before 0.12 does not properly enforce directory escapes [www.cvedetails.com] CVSS 4.6 The do_write_pids function in lxcfs.c in LXCFS before 0.12 does not properly check permissions [www.cvedetails.com] CVSS 7.2 systemd vulnerability allows attackers to hack Linux machines via malicious DNS response [latesthackingnews.com]\n\nsystemd is an init system systemd provides an UEFI boot loader, systemd-boot (previously gummiboot) systemd provides a login manager, systemd-logind systemd provides a syslog daemon, systemd-journald, see Introducing the Journal uses a binary format systemd provides a mount front-end, systemd-mount The udev sources were merged into the systemd source tree systemd provides systemd.timer timer units, which can be used to replace cron and at systemd provides a D-Bus client library, sd-bus (see sd-bus) systemd developed an in-kernel D-Bus implementation, kdbus. 
They tried to get it merged into the kernel, failed, and are now trying again with BUS1 systemd provides automount via systemd.automount to substitute autofs systemd provides a caching DNS resolver, systemd-resolved systemd provides a network manager and DHCP client, systemd-networkd systemd provides a HTTP server for journal events,systemd-journal-gatewayd (can be disabled with remote compile option) systemd Gains IP Forwarding, IP Masquerading & Basic Firewall Controls fsck cannot be cancelled (used to be possible via C-c or c on the console) systemd defaults to Google's DNS nameservers systemd defaults to Google's NTP servers, which serve leap-smeared time systemd by default uses Predictable Network Interface Names, which are actually less predictable when you only have one interface per type systemd by default kills background processes after the user logs out - \"In my view it was actually quite strange of UNIX that it by default let arbitrary user code stay around unrestricted after logout.\" -Poettering As systemd depends on many files on a rootfs, in case of any problems with rootfs, it is not able to control processes and (cleanly) shutdown/reboot when Crtl-Alt-Del is pressed systemd-resolved breaks the traditional glibc behavior by skipping a DNS server in all following queries, if it does not respond once journal ip anonymization - It's very difficult to use systemd/journal on a privacy-aware system or infrastructure. systemd mounted efivarfs read-write, allowing motherboard bricking via 'rm' systemd has a filename that starts with a hyphen! - This causes all sorts problems as it will usually be interpreted as the start of a command option when used on the command line. You don't even need to specify the filename for it to cause problems as it will affect commands that use globbing. Not to mention that the file in question, \"-.slice\", they refer to as the \"root slice\" which causes confusion as the term \"slice\" has been used for decades as an alternative way of referring to a disk partition yet their usage is completely unrelated.\nLennart's argument for mounting /sys/firmware/efi/efivars as read/write as a default behaviour doesn't hold water. Yes it's true that some tools may need to write to it but those tools are not needed for the general running of a system. efivars should not even be mounted as read-only by default. Those tools that need to write to efivars will generally only be invoked by a system administrator. A competent sysadmin will know how to mount efivars with read/write permissions when they need to to use those tools. The only reason to mount efivars by default is for convenience. This is by no means a good reason. From a security perspective, mounting efivars by default should be strongly discouraged as it breaks the principle of least privilege. Lennart goes on to state that systemd needs to write EFI variables. This demonstrates yet another example of scope creep and thus poor design.
\n\nTHINGS, SYSTEMD FORCES YOU TO DO:\n\n    systemd is tied to a specific kernel and a specific libc and specific device manager and specific journaling daemon, basically, having systemd means you're locked in to a whole lot of other things\n\n    systemd is renowned for locking up during startup and boot when you have network filesystems\n\n    systemd hardcodes quite a lot of the booting and shutdown process in C which other systems place in easily editable scripts\n\n    systemd in practice requires quite a lot of things: ACLs, PAM, dbus, polkit, these are not hard requirements but without this the above advantages are lost so all distributions enable them at compile time\n\n    logind starting to do retarded shit like user sessions and having retarded power management, in theory you can disable logind, but no distribution again does this\n\n    systemd is very monolithic and comes in one configuration compared to being able to piece your system together yourself, this sounds bad except that unless you run something like Gentoo or Exherbo you were already submitted to this, while the distribution was able to pick the choice of lower level system components before they switched to systemd, you had no choice in this and just used what your distribution stuffed you with. If your distribution used whatever cron daemon, you used that, if your distribution used consolekit1/2 you used that, if your distribution used acpid/Upower, you used that, you used whatever device manager, syslogger, init and RC your distribution used. While systemd replaces all those things and thus leaves the configuration no longer a choice for the distribution, unless you ran a meta distro that allowed you to choose those things you didn't loose much choice now did you?\n\nUhuh, hands down for the best boot analyzer around. \n"
Systemd_Bad=$(fold -sw $columns <<< $Systemd_Bad)

######## MENU ##########

options=("GNU" "No_its_linux" "Old_Man" "Proprietary_Bitch" "Ubuntu_kiddie" "Installation" "Family" "Regex" "Defend_Emacs" "Stallman_Quote" "Windows_Quote" "Systemd_Bad" "Quit")

show_dmenu() {
    choice=$(printf "%s\n" "${options[@]}" | dmenu )
    echo -e ${!choice} | xclip -selection clipboard # copy to clipboard
    exit
}


show_help() { printf "\
Usage: copypasta [options]

Options:
    -help: Show this help
    -color: Which color the text will show up as
    -dmenu: Use dmenu to select and copy pastas to clipboard\n"
exit
}


show_menu() {
    select opt in "${options[@]}"
    do
        if [[ -z $COLOR ]]; then COLOR="PURPLE"; fi
        echo -e "${!COLOR}"
        if [ -z "$opt" ]; then echo "Invalid Option"; exit; fi
        echo -e "${!opt}"
        break
    done
    exit
}

if [[ -z $1 ]]; then show_menu; fi

case $1 in
    "-color")
        COLOR="$(echo "$2" | tr '[:lower:]' '[:upper:]')"
        show_menu
        ;;
    "-help")
        show_help
        ;;
    "-dmenu")
        show_dmenu
        ;;
    *)
        echo "Invalid Argument"
        show_help
        ;;
esac

